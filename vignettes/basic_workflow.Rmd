---
title: "Basic Workflow"
output: 
  rmarkdown::html_vignette:
    keep_md: true
    toc: true
vignette: >
  %\VignetteIndexEntry{basic_workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

## Objectives

-   Perform standard data management in VigiBase ECL
-   Conduct disproportionality analysis (both univariate and multivariate)

A summary of all data management steps can be found in vignettes

\code{vignette("generic_dictionary", package = "vigicaen")}

and

\code{vignette("generic_main", package = "vigicaen")}

## Reminder of Database Structure

Each table has a unique identifying key and other keys for performing joins.

| Table  | Key           | Other keys |
|--------|---------------|------------------|
| `demo` | `UMCReportId` |                  |
| `drug` | `Drug_Id`     | `UMCReportId`    |
| `adr`  | `Adr_Id`      | `UMCReportId`    |

> Goal of the tutorial: perform a disproportionality analysis between colitis and nivolumab among checkpoint inhibitor cases.

## Step 0: Load Packages

```{r library, warning=FALSE, message=FALSE}
library(rlang)
library(vigicaen)
library(dplyr)
```

# Build tables from source files

This process should be done once per database version.

You don't have to do it to follow this tutorial, since
we will use the package built-in example tables.

However, when working on real analyses, you will need
to process this step first.

See the vignette here \code{vignette("build_tables", package = "vigicaen")}.

# Data management

## Drugs {drug_workflow}

### Principle

1.  Load the `demo`, `drug`, and `mp` tables.
2.  Select one or more medications of interest.
3.  Identify the drug codes (e.g., the `DrecNo(s)`)
associated with these drug using the `mp` (or `mp`)
table.
4.  Search for cases exposed to these medications using the codes in the `drug` table.
5.  Update the `demo` table: code 1 if the case reports the medication of interest, 0 otherwise.
6.  Check your data management

Step 1 is performed with `dt_parquet()` if you have your own tables, or using the built-in example tables for this tutorial.

Step 2 and 3 can be referred as "dictionary" steps.

Step 3 is performed with `get_drecno()` or `get_atc_code()`.

Steps 4 and 5 are performed with `add_drug()`.

step 6 is performed with `check_dm()`.

### Step 1: Load the tables

```{r table_loading, warning=FALSE, message=FALSE}
demo <- demo_
drug <- drug_

mp <- mp_
```

> Note: if you are working with your own tables, 
you will need to load them here, with `dt_parquet()`.

### Step 2: Choose drugs of Interest

This is probably the most interesting part of the process,
from a scientific point of view. But for now, it's pretty trivial.

Once you've decided which drugs you would like to study
(e.g. nivolumab in this tutorial), you need to create
a **named list** of character vectors.

```{r drug_sel}
d_sel <- # drug selection
  list2(
    nivolumab = "nivolumab"
  )

d_sel
```

### Step 3: Identify drug codes

The function `get_drecno()` allows you to query the `mp`
table with a selection of drug names.

It takes several arguments, two of which must be filled in: 
the selection of drugs and the table containing the
correspondence between the name and the code (here, `mp`).

You should **always** proceed in two steps.

1.  First, use `get_drecno()` with the `inspect = TRUE` argument

```{r inspect_with_get_drecno}
d_sel |> 
  get_drecno(
    mp = mp_,
    inspect = TRUE
  )
```

We see that `get_drecno()` finds two entries containing the drug "nivolumab" in the `mp` table:

-   The entry for nivolumab alone

-   The entry for the ipilimumab;nivolumab combination

This second entry was identified because the `allow_combination`
argument is set to TRUE by default. 
This allows for a broader identification of all specialties
containing nivolumab. In this situation, this behavior is
desirable because we want to be sure to identify all cases
reporting the drug.

2.  Since these are actually the codes we were looking for, 
we set the inspect argument to FALSE and keep the result 
in an R object called `d_drecno`.

```{r d_drecno}
d_drecno <-
  d_sel |> 
  get_drecno(
    mp = mp_,
    inspect = FALSE
  )
```

### Steps 4 and 5: add_drug() function

To identify cases reporting the drug of interest and add the
corresponding column to `demo`, we use the `add_drug()` function.

The `add_drug()` function takes 3 mandatory arguments:

-   The dataset on which to add the drug variable(s) (here, `demo`)

-   A named list containing the codes of the drug(s)

-   The `drug` table linking drug intake to each case.

```{r add_drug}
demo <- 
  add_drug(
    .data = demo,
    d_code = d_drecno,
    drug_data = drug)
demo
```

Or, in tidyverse syntax

```{r, results='hide'}
demo <- 
  demo |> 
  add_drug(
    d_code = d_drecno,
    drug_data = drug
  )
```

### Step 6: Check your data management

This may seem trivial, but it is an **essential** step 
in the construction of a dataset.

There are many ways to check that the code has worked.
Here, the `check_dm()` function will count the number of rows
in the dataset where the desired column is 1.

```{r check_dm}
demo |> 
  check_dm("nivolumab")
```

It shows how many rows in `demo` have the value 1 in the
`nivolumab` column (e.g. how many cases where identified
as reporting on nivolumab reactions). 

Here, we see that 225 cases report nivolumab.

### Step 4 and 5 variant: Suspect, concomitant, interacting

We can choose to work with drugs according to their
"reputation basis".

This information is stored in the `Basis` column of the
`drug` table.

-   1 suspect

-   2 concomitant

-   3 interacting

By using the `add_drug()` function, we can specify which
type of status we are interested in, in the `repbasis` argument.
By default, the value `"sci"` indicates that we consider the
drug whether it is suspect, concomitant, or interacting. 
We can change the selection.

```{r add_drug_repbasis}
demo |> 
  add_drug(
    d_code = d_drecno,
    drug_data = drug,
    repbasis = "sci"
  ) |> 
  check_dm("nivolumab")

# suspected only

demo |> 
  add_drug(
    d_code = d_drecno,
    drug_data = drug,
    repbasis = "s"
  ) |> 
  check_dm("nivolumab")
```


### ATC classes

The correspondence between ATC (Anatomical and Therapeutical
Classification) classes and drug codes is found in the `thg`
table. In this table, drug codes are stored as
`MedicinalProd_Id`. It is therefore necessary to make a second
correspondence with `mp` to find `DrecNo`.

This can be done with the `get_atc_code()` function.

As with drugs, we first need to identify the ATC class of interest (here, "L03").

```{r atc_drecno}
atc_sel <-
  list2(l03 = "L03")

atc_drecno <- 
  atc_sel |> 
    get_atc_code(
      mp = mp,
      thg_data = thg_
    )
```

The `get_atc_code()` function requires the `mp` 
and `thg` tables, as well as the selection of ATC classes.

```{r str_atc_drecno}
str(atc_drecno)
```

By default, this function retrieves DrecNos associated with 
an ATC class. It is possible to retrieve MedicinalProd_Ids
instead by setting the `vigilyze` argument to `FALSE`.

Once DrecNos are identified, we can add them to the `demo` table,
with the `add_drug()` function.

```{r add_atc}
demo |> 
  add_drug(
    d_code = atc_drecno,
    drug_data = drug
  )
```

### Create multiple drug columns

To work with multiple drugs, 
you need to update the initial in `d_sel` list.

```{r many_drugs}
d_sel <- 
  list2(
    nivolumab = "nivolumab",
    pembrolizumab = "pembrolizumab"
  )

d_drecno <-
  d_sel |> 
  get_drecno(mp = mp)

demo <- 
  demo |> 
  add_drug(
    d_drecno,
    drug_data = drug
  )

demo |> 
  check_dm(c("nivolumab", "pembrolizumab"))
```

### Drug groups

If you want to work at the level of a group of drugs,
but the ATC classes do not match your needs perfectly,
you can group them in the `d_sel` list.

```{r d_groups}
d_sel <- 
  list2(
    antalgiques = c("paracetamol", "tramadol"),
    ici = c("nivolumab", "pembrolizumab")
  )

d_drecno <-
  d_sel |> 
  get_drecno(mp = mp)

demo <- 
  demo |> 
  add_drug(
    d_drecno,
    drug_data = drug
  )

demo |> 
  check_dm(names(d_sel))
```

## Adverse drug reactions

### Principles

1. Load the `demo`, `adr`, and `meddra` tables.

2. Choose the adverse event(s) of interest.

3. Identify the event codes (these are low-level terms according
to the MedDRA classification). They can be found in the `meddra`
table or in the `smq` tables.

4. Search for cases that have presented this event, using the
codes

5. Update the `demo` table: code 1 if the case reports the
event of interest, 0 otherwise.

6. Check your data management

Similarly to the [drug workflow](#drug_workflow), steps
2 and 3 can be referred to as "dictionary" steps.

Step 3 uses `get_llt_soc()` or `get_llt_smq()`.

### Step 1: Load the tables

```{r load_adr_table}
adr <- adr_
meddra <- meddra_
```

demo was loaded during the [drug workflow](#drug_workflow).

### Step 2: Choose events of interest

```{r a_sel_pt}
a_sel_pt <-
  list2(
    a_colitis = c(
      "Colitis",
      "Autoimmune colitis",
      "Colitis microscopic",
      "Diarrhoea",
      "Diarrhoea haemorrhagic",
      "Duodenitis",
      "Enteritis",
      "Enterocolitis",
      "Enterocolitis haemorrhagic",
      "Ulcerative gastritis"
    )
  )
```

We start with a list of adverse events of interest, grouped
altogther under the name "a_colitis".

Be sure all selected terms belong to the same hierarchical level
(preferred term, high level term...) in MedDRA.
Here, we use Preferred Terms.

### Step 3: Identify event codes

The `get_llt_soc()` function allows you to query the `meddra`.

```{r get_llt_soc}
a_llt <- 
  get_llt_soc(
    term_sel = a_sel_pt,
    term_level = "pt",
    meddra = meddra_
    )

a_llt
```

An alternative is to use the `get_llt_smq()` function, which
allows you to query the `smq` tables.

### Steps 4 and 5: add_adr() function

The `add_adr()` function allows you to identify cases reporting
the adverse event of interest and add the corresponding column
to `demo`.

```{r add_adr}
demo <- 
  demo |> 
  add_adr(
    a_code = a_llt,
    adr_data = adr
    )
```

### Step 6: Check your data management

`check_dm()` also works for adr.

```{r check_dm_adr}
demo |> 
  check_dm("a_colitis")
```

## Other variables

We may need to create other variables to perform our analysis,
for example age and sex in a multivariable analysis.

### Age

The `demo` table contains the `AgeGroup` column, which groups
ages into categories. You may want to recode it to match 
you research question

```{r age}
demo <-
  demo |>
  mutate(
    age = cut(as.integer(AgeGroup),
              breaks = c(0,4,5,6,7,8),
              include.lowest = TRUE, right = TRUE,
              labels = c("<18", "18-45","45-64", "65-74", "75+"))
  )
```

### Sex

The `demo` table contains the `Gender` column, from which
you can also create a new sex column (with values 1 for
men, 2 for women, and NA otherwise)

```{r sex}
demo <-
  demo |> 
  mutate(
    sex = ifelse(Gender == "1", 1,
                 ifelse(Gender == "2", 2, NA_real_)
                 )
    )
```

### Using case_when()

The `case_when()` function from the `dplyr` package allows
you to manage multiple options in a single function, with
a slightly different syntax.


```{r sex_casewhen}
demo <- 
  demo |> 
  mutate(
    sex = case_when(Gender == "1" ~ 1,
                    Gender == "2" ~ 2,
                    TRUE ~ NA_real_)
    )
```

More documentation on `case_when()` can be found in the
`dplyr` package documentation.

You should just remember here that options are evaluated
sequentially, from top to bottom.


### Seriousness, death

The `out` table contains the `Seriousness` column, which
indicates whether the case was serious or not, and whether
the patient experienced a fatal issue during his/her follow-up.

```{r serious_death}
# ---- Serious ---- ####

out <- out_

demo <- 
  demo |> 
  mutate(
    serious = ifelse(UMCReportId %in% out[, UMCReportId],
                      UMCReportId %in% out[Serious == "Y", UMCReportId],
                      NA)
    )

# ---- Death + outcome availability ---- ####

demo <- 
  demo |> 
  mutate(death = 
           ifelse(UMCReportId %in% out[, UMCReportId],
                  UMCReportId %in% out[Seriousness == "1",
                                       UMCReportId],
                  NA)
         )

```

-  The `serious` and `death` columns are coded with TRUE/FALSE values in
this example. There is no particular reason to prefer it over 1/0
codes. It is just a matter of preference.

-  The `Seriousness` can have several levels, level 1 being death.
(see subsidiary files)

# Disproportionality

Our `demo` dataset now has a drug column for nivolumab, 
and an adr column for colitis.

We can now perform a disproportionality analysis between these
two variables.


## Univariate analysis

### Disproportionality metrics

Reporting Odds-Ratio (ROR) and Information Component
essentially measure the same thing: the disproportionality.

Both are calculated using a contingency table. 
We just need to find a, b, c, and d to get their estimation.


| Counts | nivolumab == 1 | nivolumab == 0 |
|-----------|-------------|-------------|
| a_colitis == 1  | a           | c           |
| a_colitis == 0  | b           | d           |

### Counts, compute_or_abcd()

#### Doing it by hand

Those four numbers could be retrieved "by hand"

```{r abcd}
a <- 
  demo |> 
  filter(nivolumab == 1 & 
           a_colitis == 1) |> 
  summarise(n()) |> 
  pull()

b <- 
  demo |> 
  filter(nivolumab == 1 & 
           a_colitis == 0) |> 
  summarise(n()) |> 
  pull()

c <- 
  demo |> 
  filter(nivolumab == 0 & 
           a_colitis == 1) |> 
  summarise(n()) |> 
  pull()

d <- 
  demo |> 
  filter(nivolumab == 0 & 
           a_colitis == 0) |> 
  summarise(n()) |> 
  pull()
```

With the Reporting Odds-Ratio being $\frac{ad}{bc}$\,
its standard error $\sqrt{\frac{1}{a} + \frac{1}{b} + \frac{1}{c} + \frac{1}{d}}$\
and the confidence interval boundaries at 95% being $± ~1.96 * \text{se}$.

We could also calculate the Information Component.

The `compute_or_abcd()` function does it for us.
(both ROR and IC)

```{r compute_or_abcd}
demo |> 
  compute_or_abcd(
    y = "a_colitis",
    x = "nivolumab"
    )
```

## Advanced modelling, multivariate analysis

From this point, it is also possible to run any statistical model
including drug and adr parameters, but also potential other variables
such as age and sex. For example, one could wish to perform
a multivariate logistic regression on the reporting of colitis
and nivolumab, adjusted on age and sex.

The `glm()` function from the `stats` package can be use for this
purpose.


```{r mod}
mod <- glm(a_colitis ~ nivolumab, 
           data = demo, family = "binomial")

summary(mod)
```

In a logistic regression models, estimates lead to (reporting) OR by the exponential.

```{r}
summary(mod)$coefficients

exp(summary(mod)$coefficients[2, 1])
```

Adding covariates is straightforward

```{r mod_covar}
mod2 <- glm(a_colitis ~ nivolumab + sex + age,
            data = demo,
            family = "binomial")

summary(mod2)
```

### Extract Odds-Ratio with compute_or_mod()

There are several packages that can extract the OR from a model.
The `compute_or_mod()` function is just one of many ways to do it.

```{r compute_or_mod}
mod_or <- 
  compute_or_mod(
    summary(mod2)$coefficients,
    estimate = Estimate,
    std_er = Std..Error
    )

mod_or
```

# Interactions

## Introduction

It is possible to explore interactions between drugs on
an adr reporting.

This tutorial does not aim at covering the concepts underlying
interactions in pharmacovigilance.

We use a cleaned dataset, from the example tables.

```{r interaction_dm}

# ---- Tables ---- ####

demo <- demo_
drug <- drug_

# ---- Dictionary step ---- ####

d_drecno <- ex_$d_drecno
a_llt <- ex_$a_llt

# #### Data management #### ####

# ---- Drugs ---- ####

demo <-
    demo |>
    add_drug(
      d_code = d_drecno,
      drug_data = drug_
    ) 

# ---- Adrs ---- ####

demo <- 
  demo |>
    add_adr(
      a_code = a_llt,
      adr_data = adr_
    )

# ---- Sex ---- ####

demo <- 
  demo |> 
  mutate(
    sex = case_when(Gender == "1" ~ 1,
                    Gender == "2" ~ 2,
                    TRUE ~ NA_real_)
    )
```

## Additive interactions

### Multivariate analysis

Additive effect of two covariates can be obtained by multiplying 
the Odds-Ratio of each.

```{r mod_inter}
mod3 <- glm(a_colitis ~ ipilimumab + sex,
            data = demo,
            family = "binomial")

mod_or <- 
  compute_or_mod(
  summary(mod3)$coefficients,
      estimate = Estimate,
    std_er = Std..Error
  ) |> select(rn, orl, ci, up_ci)

mod_or
```

```{r echo=FALSE}
ror_ipi <- mod_or[rn == "ipilimumab", orl]
ror_sex <- mod_or[rn == "sex", orl]
```
With reporting Odds-Ratio of ipilimumab being `r ror_ipi`
and the reporting Odds-Ratio of sex being `r ror_sex`, 
the additive effect of both is `r ror_ipi` * `r ror_sex`.

### Subgroup comparisons

Some way to approach multiplicative interactions is to compare
the disproportionality signal in subgroups.

The `compute_or_abcd()` function can be used for these analyses,
assuming the initial dataset is filtered on the appropriate
subgroup.

Say we want to investigate the interaction between ipilimumab
and nivolumab and colitis reporting.

```{r}
demo |> 
  filter(nivolumab == 1) |> 
  compute_or_abcd(
    y = "a_colitis",
    x = "ipilimumab"
    )
```
The overall analysis implies to perform additional analysis in
different settings.

In our example:

-   If ipilimumab alone leads to an overreporting of colitis
-   If nivolumab, among ipilimumab cases, leads to an overreporting of colitis
-   If the combination ipilimumab + nivolumab versus any control
(or the whole dataset) increases the notifications of colitis.

Both IC and ROR can be used here.

## Statistical interactions {#inter_stat}

### Logistic regression model

The true statistical interaction is obtained with the following
model

```{r}
mod4 <- glm(a_colitis ~ ipilimumab + sex + ipilimumab * sex,
            data = demo,
            family = "binomial")

compute_or_mod(
  summary(mod4)$coefficients,
  estimate = Estimate,
  std_er = Std..Error
)
```

### Bayesian Information Component

The formula for the interaction between 3 variables 
(y, the event of interest, x1 and x2,
two potential explanatory factors) 
in information component is

$log_2\frac{n_{y, x1, x2}}{n.expected_{interaction}}$

with $n.expected_{interaction}$ equal to

$\frac{n_{x1, x2} * n_{y, x1} * n_{y, x2} * n.total}{n_{x1} * n_{x2} * n_y}$

The parameters are read as follows

| Parameter       | Case                                                                      |
|-----------------|-------------------------------------------------------|
| $n_{x1}$        | number of cases reporting x1                                              |
| $n_{x1, x2}$    | number of cases reporting x1 **AND** x2                                    |
| $n_{y, x1, x2}$ | number of cases reporting x1 **AND** x2 **AND** y                           |
| $n.total$       | total number of cases in the study population  |

The credibility interval is calculated as for the usual IC.

The `ic_tail()` function can be used as a shortcut.
